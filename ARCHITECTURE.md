# 아키텍처

이 문서에서는 본 소스가 어떤 식으로 구성되어있는지 설명한다.

## 개요 및 초기 아이디어

`slack_bolt` 라이브러리를 근간에 두고 있다. 일종의 flask wrapper framework 로 보면 될 듯 하다. 

이 프레임워크 덕분에, 메타태그인지 어노테이션인지 하여튼 `@app.event({"type": "message"})` 이런 키워드를 이용해 특정 이벤트에 대한 웹훅을 수신할 수 있다.
\
(코드에서는 이벤트를 받을 수 있도록 추가하고, [Anna 앱 설정](https://api.slack.com/apps/AR4RK9XGX/event-subscriptions) - 'Subscribe to bot events' 에서도 슬랙이 해당 이벤트를 날리도록 개별 이벤트를 등록해야됨)

그래서 각 이벤트를 -> 특정 서비스들의 handler가 선택적으로 수신하고 -> 이 handler 들이 service 인스턴스를 만들어서 -> 실제 비즈니스 수행은 service에서 하도록 만들었다.

## 개선된 아키텍처

그런데 위와 같이 하고 보니까 다음과 같은 생각이 들었다. '아니 그냥 모든 이벤트를 모든 핸들러가 수신하고, 지금 이 이벤트가 자신의 비즈니스 로직을 수행해야되는 이벤트인지 판단하면 되는거 아냐?' 따라서,

- "각 이벤트를 '각 핸들러가' 스스로 걸러내게 하면?" -> "모든 이벤트를 모든 핸들러가 동시에 받고 알아서 걸러낸다"
- "핸들러랑 서비스를 분리할 필요가 있나?" -> "모든 이벤트는 모든 서비스가 바로 받는다"
- "그런데 그러면 테스트하기 너무 힘들어지지 않을까?" -> "테스트가 어려운 지점이 생길 때, 해당 부분을 별도 클래스로 분리해내자"

그 결과 다음과 같은 디자인이 완성되었다:

- anna 에서 서버를 가동시킨다. 아래에 설명되지 않은 항목들이 여기에 담긴다. 예를 들면 환경변수 세팅.
- router에서, slack으로부터 날라오는 event들을 모두 한 곳으로 모으고 이것을 service들에 넘긴다.
- 각 service는 해당 이벤트가 본인이 액션을 취해야 하는지 판단한다.
  - 여러 service가 동일한 이벤트를 받아 서로 다른 액션을 취할 수도 있다. service는 개별 '기능'에 따라 만들기 때문. 
    - 예를 들어 '메시지에 이모지가 달림' event를 처리하는 handler는, 특정 이모지에 대해서 SpreadSheetService와 ReplyService를 같이 실행할 수도 있다.
- 각 service는 도메인 로직을 최대한 '말하듯이' 묘사하고, 실제 수행은 implentation 레이어로 위임한다.

그림으로 나타내면 다음과 같다:

```text
                                                                                                                                                   
                                                                                                ┌──────────┐                       ┌────────┐     
                                                                                        ┌────►  │ serviceA │  "no"          ┌────► │ impleI │     
                                                                                        │       └──────────┘                │      └────────┘     
                                                                                        │                                   │                     
┌────────┐   do_something   ┌───────┐   send_event    ┌────────┐ "is this your target?" │       ┌──────────┐"yes, do i/j/k" │      ┌────────┐     
│  user  │  ──────────────► │ slack │  ─────────────► │ router │ ───────────────────────┼────►  │ serviceB ├────────────────┼────► │ impleJ │     
└────────┘                  └───────┘                 └────────┘                        │       └──────────┘                │      └────────┘     
                                                                                        │                                   │                     
                                                                                        │       ┌──────────┐                │      ┌────────┐     
                                                                                        └────►  │ serviceC │  "no"          └────► │ impleK │     
                                                                                                └──────────┘                       └────────┘     
                                                                                                                                                   
```

위에서 설명되지 않은 디렉토리는 다음과 같다:

- configuration : 각종 세팅을 init 메소드들. 메인 파일(anna.py) 사이즈를 줄이기 위해 분리함.
- exception : 공통적으로 사용하는 예외들
- router : 이벤트 리스너들을 활성화시키고, 동시에 리스너가 서비스들을 호출하도록 연결해주는 메소드가 있음.
- util : 똑같은 걸 너무 자주써서 여기에 둠 
- tests : 테스트

## 특이사항

외부 연동되는 건 implementation 레이어로 빠지게 유도했지만, slack과 통신하는 부분(Say, WebClient)은 service 레이어에 두었다. 매번 리스터가 호출될 때마다 Say, WebClient 가 만들어지기 때문에 억지로 implementation 레이어로 끌어내리는게 번잡스러웠음.

하지만 그렇다고 모든 로직을 service 메소드에 나열하는 건 이상하다고 생각되어, 각 로직의 덩치가 조금이라도 커지려고 하면 helper 메소드로 추출하였다. 그래서 결과적으로 테스트 코드는 이 helper 메소드들을 중심으로 짜게되었다.
\
예를 들어 qna 모듈은 `__init__.py` 에 나와있는 `reply_to_question()` 메소드만 외부로 노출되고, 나머지 `is_message_sent_event()`, `find_keyword()`, `find_reply()`는 helper 역할을 한다. 