# 아키텍처

이 문서에서는 본 소스가 어떤 식으로 구성되어있는지 설명한다. 글의 아래 부분으로 내려갈수록 점점 최신 상태를 설명한다....

## 개요 및 초기 아이디어

`slack_bolt` 라이브러리를 근간에 두고 있다. 일종의 flask wrapper framework 로 보면 될 듯 하다. 

이 프레임워크 덕분에, 메타태그인지 어노테이션인지 하여튼 `@app.event({"type": "message"})` 이런 키워드를 이용해 특정 이벤트에 대한 웹훅을 수신할 수 있다.
\
(코드에서는 이벤트를 받을 수 있도록 추가하고, [Anna 앱 설정](https://api.slack.com/apps/AR4RK9XGX/event-subscriptions) - 'Subscribe to bot events' 에서도 슬랙이 해당 이벤트를 날리도록 개별 이벤트를 등록해야됨)

그래서 각 이벤트를 -> 특정 서비스들의 handler가 선택적으로 수신하고 -> 이 handler 들이 service 인스턴스를 만들어서 -> 실제 비즈니스 수행은 service에서 하도록 만들었다.

## 개선된 아키텍처

그런데 위와 같이 하고 보니까 다음과 같은 생각이 들었다. '아니 그냥 모든 이벤트를 모든 핸들러가 수신하고, 지금 이 이벤트가 자신의 비즈니스 로직을 수행해야되는 이벤트인지 판단하면 되는거 아냐?' 따라서,

- "각 이벤트를 '각 핸들러가' 스스로 걸러내게 하면?" -> "모든 이벤트를 모든 핸들러가 동시에 받고 알아서 걸러낸다"
- "핸들러랑 서비스를 분리할 필요가 있나?" -> "모든 이벤트는 모든 서비스가 바로 받는다"
- "그런데 그러면 테스트하기 너무 힘들어지지 않을까?" -> "테스트가 어려운 지점이 생길 때, 해당 부분을 별도 클래스로 분리해내자"

그 결과 다음과 같은 디자인이 완성되었다:

- anna 에서 서버를 가동시킨다. 아래에 설명되지 않은 항목들이 여기에 담긴다. 예를 들면 환경변수 세팅.
- router에서, slack으로부터 날라오는 event들을 모두 한 곳으로 모으고 이것을 service들에 넘긴다.
- 각 service는 해당 이벤트가 본인이 액션을 취해야 하는지 판단한다.
  - 여러 service가 동일한 이벤트를 받아 서로 다른 액션을 취할 수도 있다. service는 개별 '기능'에 따라 만들기 때문. 
    - 예를 들어 ':고고: 이모지가 추가됨' 이라는 event 하나에, 두 개 이상의 service 가 반응하고 액션을 취할 수도 있다.
- 각 service는 도메인 로직을 최대한 '말하듯이' 묘사하고, 실제 구체적인 수행은 implentation 레이어로 위임한다.

그림으로 나타내면 다음과 같다:

```text
                                                                                                                                                   
                                                                                                ┌──────────┐                       ┌────────┐     
                                                                                        ┌────►  │ serviceA │  "no"          ┌────► │ impleI │     
                                                                                        │       └──────────┘                │      └────────┘     
                                                                                        │                                   │                     
┌────────┐   do_something   ┌───────┐   send_event    ┌────────┐ "is this your target?" │       ┌──────────┐"yes, do i/j/k" │      ┌────────┐     
│  user  │  ──────────────► │ slack │  ─────────────► │ router │ ───────────────────────┼────►  │ serviceB ├────────────────┼────► │ impleJ │     
└────────┘                  └───────┘                 └────────┘                        │       └──────────┘                │      └────────┘     
                                                                                        │                                   │                     
                                                                                        │       ┌──────────┐                │      ┌────────┐     
                                                                                        └────►  │ serviceC │  "no"          └────► │ impleK │     
                                                                                                └──────────┘                       └────────┘     
                                                                                                                                                   
```

위에서 설명되지 않은 디렉토리는 다음과 같다:

- configuration : 각종 세팅을 init 메소드들. 메인 파일(anna.py) 사이즈를 줄이기 위해 분리함.
- exception : 공통적으로 사용하는 예외들
- router : 이벤트 리스너들을 활성화시키고, 동시에 리스너가 서비스들을 호출하도록 연결해주는 메소드가 있음.
- util : 똑같은 걸 너무 자주써서 여기에 둠 
- tests : 테스트

## 특이사항

외부 연동되는 건 implementation 레이어로 빠지게 유도했지만, slack과 통신하는 부분(Say, WebClient)은 service 레이어에 두었다. 매번 리스터가 호출될 때마다 Say, WebClient 가 만들어지기 때문에 억지로 implementation 레이어로 끌어내리는게 번잡스러웠음.

하지만 그렇다고 모든 로직을 service '메소드'에 나열하는 건 이상하다고 생각되어, 각 로직의 덩치가 조금이라도 커지려고 하면 개별 helper 메소드로 추출하였다. 그래서 결과적으로 테스트 코드는 이 helper 메소드들을 중심으로 짜게되었다.
\
예를 들어 qna 모듈은 `__init__.py` 에 나와있는 `reply_to_question()` 메소드만 외부로 노출되고, 나머지 `is_message_sent_event()`, `find_keyword()`, `find_reply()`는 helper 역할을 한다. 


### 조금 더 변형된 아키텍처

(위에보다 더 안좋아짐) 소스코드가 망가지고 있음. 무리한(?) 객체지향코드를 작성하다보니, implementation 과 service 계층이 매우 흐려졌음.

현재는, 그 두 모듈을 크게 구분하지 않고, 그냥 "왠지 분리할 만한데" 싶은 것들은 별도 파일/클래스로 뽑아서 만들었음. 

이 "왠지"는 두 가지 느낌에 기인하는데,

- 기존 코드가 테스트하기 힘들어보일만큼 덩치가 큰데, 요렇게 저렇게 뚝 떼내면 걔만 테스트하는 건 쉬울 것 같아 ~~그러나 그렇게 분리해놓고 테스트하지 않은 구석이 많음~~
- 이 덩어리는 하나로 떼내서 나름의 '역할'을 한다고 말할 수 있을 것 같아 ~~그러나 그렇게 분리된 애를 다른데서 재활용하지는 않음. 물론 재활용하는게 객체지향의 본질은 아니지만 오히려 가독성을 해친 느낌도 쪼끔 있음~~

그리고 이미 위에서 말했어야 하는 건데, slack_bolt 레포지토리에서 받은 [답변](https://github.com/slackapi/bolt-python/issues/697)에 따르면, 매번 이벤트 발생 시마다 주어지는 객체들 -- `Say`, `WebClient` -- 들을 가급적이면 매번 새로 받아서 사용하라고 한다. 그 말인 즉슨, 내가 만든 객체들이 그런... `slack_bolt` 의 객체들을 의존성으로 물고싶다면 모든 이벤트 요청마다 DI 를 새로 해야된다는 것이다. **결과적으로, 현재는 매 이벤트 발생마다 의존성을 새로 주입하고 있다.** (`participate_offline_meeting()` 메소드를 참고할 것) 나는 도대체 이게 맞는 방향인지 분간이 안되는 상태이다.